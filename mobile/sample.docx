

1. Test Entry Point ‚Äì QASplashScreenActivityTest.kt
	‚Ä¢	Purpose: End-to-end test that validates login flow from splash to phone number entry.
	‚Ä¢	Structure:
	‚Ä¢	Uses JUnit4 with @RunWith(AndroidJUnit4::class)
	‚Ä¢	@Rule: composeTestRule to test Compose UIs
	‚Ä¢	@Before setup for IdlingPolicies and registering theme
	‚Ä¢	@Test function welcome_to_login_happy_path() walks through real user journey
	‚Ä¢	Reasoning:
	‚Ä¢	Follows Robot Pattern to separate UI interactions (LoginScreenRobot, WelcomeScreenRobot) from test logic.
	‚Ä¢	Compose + View-based test rules coexist, which allows hybrid UI testing.

‚∏ª

2. TestHarness.kt and TestLauncherActivity.kt
	‚Ä¢	Purpose: Dynamically configure the environment for the test: stubbed state, feature flags, theme, etc.
	‚Ä¢	What it does:
	‚Ä¢	TestHarness.intent(...): builds a custom Intent using a data class (TestHarness.Config)
	‚Ä¢	TestLauncherActivity: Receives extras and injects correct test dependencies (via Dagger)
	‚Ä¢	Why this matters:
	‚Ä¢	Enables reusable, configurable, and isolated test setup
	‚Ä¢	Eliminates hardcoded mocks and promotes flexibility for new test scenarios

‚∏ª

3. TestApp.kt
	‚Ä¢	Purpose: Replace production dependencies with mock implementations
	‚Ä¢	Highlights:
	‚Ä¢	Overrides getBrandModule(), getFraudSettings(), getFeatureFlagRepository()
	‚Ä¢	Uses MockFeatureConfig, TestFraudSettings
	‚Ä¢	Why this matters:
	‚Ä¢	Ensures test environment is fully controlled
	‚Ä¢	No API calls or production dependencies ‚Äì all mocked using test-safe providers

‚∏ª

4. SplashActivity.kt
	‚Ä¢	Purpose: Entry point of the app. Test navigates through this using TestLaunchActivity
	‚Ä¢	Key logic for test:
	‚Ä¢	Accepts flags like EXTRA_SHOULD_FINISH and EXTRA_NAVIGATION_ENTRY_POINT
	‚Ä¢	Injects correct component (SplashComponent) for dependency setup
	‚Ä¢	Use in test:
	‚Ä¢	Test passes through SplashActivity when launched via TestHarness

‚∏ª

5. Robot Classes ‚Äì WelcomeScreenRobot.kt, LoginScreenRobot.kt, MIScreenRobot.kt, etc.
	‚Ä¢	Purpose: Provide readable, declarative, reusable test actions
	‚Ä¢	Example:

LoginScreenRobot()
   .isLoginScreenVisible()
   .enterUsername("admin")
   .enterPassword("password123")
   .clickLogin()


	‚Ä¢	Benefits:
	‚Ä¢	Highly readable, looks like a scenario spec
	‚Ä¢	Reusability: Robots can be used in multiple tests
	‚Ä¢	Keeps test logic free from view lookups or matchers

‚∏ª

üß† Why This Architecture?

Feature	Benefit
TestHarness + Launcher	Full control over app state, decouples tests from production launcher
TestApp.kt	Dependency Injection swapping without affecting production
Robot Pattern	Readable, maintainable, test actions reusable across scenarios
Compose + View Support	Allows hybrid migration toward Compose without rewriting old flows
Modular Setup	Framework lives in ui-module, reused by nga, lloyds, etc.




üß± 1. Framework Architecture Overview

‚ÄúOur ui-module test framework is structured with clear separation of concerns into:‚Äù

Layer	Purpose
actions/	Encapsulate user interaction behaviors (clicks, scrolls, typing, etc.)
assertions/	Wrap standard and custom assertions using matchers
matchers/	Provide reusable custom matchers (withDrawable, withTextColor, etc.)
builders/	Fluent DSL-style builders for test matchers
robots/	High-level page object abstractions to make test steps readable
tests/	Real UI tests showcasing how the framework is used


‚∏ª

üì¶ 2. Actions: ClickActions, ScrollActions, TextActions

‚ÄúThese are reusable wrappers around ViewActions with additional utilities.‚Äù

Example:

ClickActions.clickWithId(R.id.button)
ClickActions.clickChildWithId(R.id.parentView, R.id.childView)
TextActions.replaceText(R.id.textInput, "Hello", closeKb = true)

Why This?
	‚Ä¢	Standardizes interaction logic
	‚Ä¢	Makes custom complex clicks easy to reuse
	‚Ä¢	Replaces raw onView(...).perform(...) scattered everywhere

‚∏ª

‚úÖ 3. Assertions: BaseAssertions, DefaultAssertions

‚ÄúAssertion interfaces abstract away raw onView().check() calls.‚Äù

Example:

isDisplayed(R.id.button)
isNotDisplayed(R.id.errorText)
isChecked(R.id.toggleSwitch)
hasTag(R.id.view, "important_tag")

Why This?
	‚Ä¢	Reusable and overrideable (e.g., in brand-specific assertions)
	‚Ä¢	Easy to mock or log failures
	‚Ä¢	Reduces boilerplate from all test files

‚∏ª

üîç 4. Matchers: BaseMatchers.kt, WithText.kt, WithDrawable.kt, etc.

‚ÄúMatchers encapsulate custom logic for checking drawable, color, enabled state, etc.‚Äù

Example:

withText("Hello World")
withDrawable(R.drawable.icon_done)
withTextColor(R.color.red)
isEnabled()

Why This?
	‚Ä¢	Avoid repeating matcher logic across multiple tests
	‚Ä¢	Enables writing expressive DSL-style assertions

‚∏ª

üß± 5. Builder DSLs: ViewBuilder.kt, RootBuilder.kt

‚ÄúWe introduced builder classes to combine multiple matchers in a readable way.‚Äù

Example:

ViewBuilder()
  .withId(R.id.myView)
  .withText("Submit")
  .isEnabled()

Why This?
	‚Ä¢	Encourages declarative test writing
	‚Ä¢	Fluent DSLs improve readability, onboarding, and maintenance

‚∏ª

ü§ñ 6. Robots: AccordionRobot, CheckboxRobot, SwitchViewRobot, etc.

‚ÄúRobots act as high-level page objects for UI components.‚Äù

Example:

accordionScreen {
    clickAccordion()
    assertAccordionHeaderIsDisplayed("Section 1")
}

Why This?
	‚Ä¢	Test code reads like user flows
	‚Ä¢	Allows defining reusable, branded, or platform-specific test behaviors
	‚Ä¢	Abstracts UI internals from tests

‚∏ª

üß™ 7. Real Tests: ComponentListUITest.kt, AccordionUITest.kt, etc.

‚ÄúThese are example tests that prove our framework is usable, modular, and composable.‚Äù

Example:

@Test
fun test_checkbox_screen_displayed_in_xml() {
    checkboxScreen {
        clickCheckboxWithText("Java")
        assertCheckedWithText("Java")
        assertCheckboxWithTextIsDisabled("React native")
    }
}

Why This?
	‚Ä¢	Demonstrates how robots + actions + assertions + matchers come together
	‚Ä¢	Ensures framework is production-ready and reusable
	‚Ä¢	Acts as documentation for future engineers

‚∏ª

üß† Final Talking Points for Your Seniors

‚úÖ Why did we build this framework?

‚ÄúTo reduce test duplication, enforce consistency, support modular test development, and provide brand-specific overrides if needed.‚Äù

‚∏ª

‚úÖ What benefits have we seen?
	‚Ä¢	Readable, reusable tests that follow the robot pattern
	‚Ä¢	Easy to add new components or extend actions/matchers
	‚Ä¢	Cross-brand reusability (e.g., lloyds, halifax, mbna)
	‚Ä¢	Faster developer onboarding

‚∏ª
