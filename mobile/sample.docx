

1. Test Entry Point â€“ QASplashScreenActivityTest.kt
	â€¢	Purpose: End-to-end test that validates login flow from splash to phone number entry.
	â€¢	Structure:
	â€¢	Uses JUnit4 with @RunWith(AndroidJUnit4::class)
	â€¢	@Rule: composeTestRule to test Compose UIs
	â€¢	@Before setup for IdlingPolicies and registering theme
	â€¢	@Test function welcome_to_login_happy_path() walks through real user journey
	â€¢	Reasoning:
	â€¢	Follows Robot Pattern to separate UI interactions (LoginScreenRobot, WelcomeScreenRobot) from test logic.
	â€¢	Compose + View-based test rules coexist, which allows hybrid UI testing.

â¸»

2. TestHarness.kt and TestLauncherActivity.kt
	â€¢	Purpose: Dynamically configure the environment for the test: stubbed state, feature flags, theme, etc.
	â€¢	What it does:
	â€¢	TestHarness.intent(...): builds a custom Intent using a data class (TestHarness.Config)
	â€¢	TestLauncherActivity: Receives extras and injects correct test dependencies (via Dagger)
	â€¢	Why this matters:
	â€¢	Enables reusable, configurable, and isolated test setup
	â€¢	Eliminates hardcoded mocks and promotes flexibility for new test scenarios

â¸»

3. TestApp.kt
	â€¢	Purpose: Replace production dependencies with mock implementations
	â€¢	Highlights:
	â€¢	Overrides getBrandModule(), getFraudSettings(), getFeatureFlagRepository()
	â€¢	Uses MockFeatureConfig, TestFraudSettings
	â€¢	Why this matters:
	â€¢	Ensures test environment is fully controlled
	â€¢	No API calls or production dependencies â€“ all mocked using test-safe providers

â¸»

4. SplashActivity.kt
	â€¢	Purpose: Entry point of the app. Test navigates through this using TestLaunchActivity
	â€¢	Key logic for test:
	â€¢	Accepts flags like EXTRA_SHOULD_FINISH and EXTRA_NAVIGATION_ENTRY_POINT
	â€¢	Injects correct component (SplashComponent) for dependency setup
	â€¢	Use in test:
	â€¢	Test passes through SplashActivity when launched via TestHarness

â¸»

5. Robot Classes â€“ WelcomeScreenRobot.kt, LoginScreenRobot.kt, MIScreenRobot.kt, etc.
	â€¢	Purpose: Provide readable, declarative, reusable test actions
	â€¢	Example:

LoginScreenRobot()
   .isLoginScreenVisible()
   .enterUsername("admin")
   .enterPassword("password123")
   .clickLogin()


	â€¢	Benefits:
	â€¢	Highly readable, looks like a scenario spec
	â€¢	Reusability: Robots can be used in multiple tests
	â€¢	Keeps test logic free from view lookups or matchers

â¸»

ðŸ§  Why This Architecture?

Feature	Benefit
TestHarness + Launcher	Full control over app state, decouples tests from production launcher
TestApp.kt	Dependency Injection swapping without affecting production
Robot Pattern	Readable, maintainable, test actions reusable across scenarios
Compose + View Support	Allows hybrid migration toward Compose without rewriting old flows
Modular Setup	Framework lives in ui-module, reused by nga, lloyds, etc.


â¸»
