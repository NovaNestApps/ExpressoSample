Here is a comprehensive Confluence document draft for your Custom Espresso UI Testing Framework implemented in the ui module repo. You can directly paste this into Confluence, and it will render well using standard formatting blocks like headings, tables, and code snippets.

â¸»

ğŸ§ª Custom Espresso UI Testing Framework â€” ui-module

ğŸ“ Repo Location: vbp-mobile-android/ui-testing

ğŸ§± Purpose: Abstract and modularize reusable test actions, assertions, matchers, builders, and test robots for XML-based UI components in Espresso UI tests. This enables clean, readable, and scalable test cases in downstream modules like nga.

â¸»

ğŸ”§ Architecture Overview

ui-testing/
â”œâ”€â”€ espresso/
â”‚   â”œâ”€â”€ actions/
â”‚   â”œâ”€â”€ assertions/
â”‚   â”œâ”€â”€ builders/
â”‚   â”œâ”€â”€ matcher/
â”‚   â”œâ”€â”€ robots/
â”‚   â””â”€â”€ rules/
â””â”€â”€ test/

Each folder maps to a specific test responsibility, e.g., interaction (actions), verification (assertions), view resolution (matcher), structure (builder), and composition (robots).

â¸»

âš™ï¸ 1. Actions (espresso/actions)

These are encapsulated test operations (click, swipe, scroll, type text, etc.) for reuse across screens.

ğŸ“ Files:
	â€¢	Actions.kt â†’ Wrapper around all types of actions
	â€¢	ClickActions.kt, ScrollActions.kt, TextActions.kt, SwitchActions.kt, etc.

âœ… Examples:

Actions.click()                    // Performs a standard click
Actions.typeText("email@x.com")   // Types text in field
Actions.setSwitchState(true)      // Toggles a switch to ON
Actions.clickItemAtPosition(0)    // Clicks first item in RecyclerView

Supports:
	â€¢	Click, DoubleClick, LongClick
	â€¢	ScrollToView
	â€¢	SwipeLeft/Right/Down
	â€¢	Text typing, replacement
	â€¢	IME actions
	â€¢	Soft keyboard close
	â€¢	Back press
	â€¢	Switch state toggle

â¸»

ğŸ” 2. Matchers (espresso/matcher)

These are custom view matchers for building specific test conditions.

ğŸ“ Files:
	â€¢	BaseMatchers.kt, WithText.kt, WithEnabled.kt, etc.
	â€¢	ViewBuilder.kt, RootBuilder.kt â€“ builders that compose matchers programmatically.

âœ… Examples:

withText("Submit")
withEnabled()
withToolbarTitle("Home")
withPasswordTransformation()

Also supports:
	â€¢	Matching by tag, regex, ID, enabled/disabled state, hierarchy
	â€¢	RecyclerView item at position
	â€¢	Root dialog/window/popup type

â¸»

ğŸ”’ 3. Assertions (espresso/assertions)

Used to validate state of views.

ğŸ“ Files:
	â€¢	BaseAssertions.kt (interface)
	â€¢	DefaultAssertions.kt (implementation)
	â€¢	CustomAssertions.kt, LayoutAssertions.kt (special cases)

âœ… Examples:

DefaultAssertions.isDisplayed(R.id.buttonSubmit)
DefaultAssertions.isNotEnabled(withText("Send"))
DefaultAssertions.hasTag("warning")

Supports:
	â€¢	isDisplayed / isNotDisplayed (by ID or matcher)
	â€¢	isCompletelyDisplayed
	â€¢	isEnabled / isDisabled
	â€¢	hasTag, doesNotExist, matches(), etc.

â¸»

ğŸ— 4. Builders (espresso/builders)

Provides dynamic matchers and root configuration for complex or multiple-view scenarios.

âœ… ViewBuilder.kt:

ViewBuilder()
   .withId(R.id.loginButton)
   .withText("Login")

âœ… RootBuilder.kt:

RootBuilder()
   .isDialog()
   .isPlatformPopup()


â¸»

ğŸ¤– 5. Robots (espresso/robots)

Implements the robot pattern for clean and expressive DSL-style test scenarios. Each screen/component has its own robot.

ğŸ“ Files:
	â€¢	AccordionViewRobot.kt
	â€¢	InputFieldViewRobot.kt
	â€¢	CallToActionViewRobot.kt

âœ… Example Usage:

callToActionScreen {
    clickButton(R.id.primaryButton)
    assertEnabled(R.id.primaryButton)
    assertTextDisplayed("Primary button")
}

Robots encapsulate:
	â€¢	Clicks on components
	â€¢	View assertions
	â€¢	Text typing
	â€¢	Error validation

â¸»

ğŸ§ª 6. Test DSLs & Entry Points

Tests invoke robot flows using DSL entry functions:

accordionScreen { ... }
callToActionScreen { ... }
inputFieldScreen { ... }

Located in:

ComponentListUITest.kt
ComponentListUITest.kt
InputFieldViewRobot.kt

Each robot is declared like this:

fun accordionScreen(func: AccordionViewRobot.() -> Unit) = AccordionViewRobot().apply(func)


â¸»

ğŸ“Œ 7. Example: InputFieldViewRobot

fun typeInSearch(text: String) {
    Actions.replaceText(R.id.searchEditText, text, closeKb = true)
}

fun assertHintFieldVisible() {
    DefaultAssertions.isDisplayed(R.id.hintTextCase)
}

And its usage:

callToInputFieldScreen {
    assertHintFieldVisible()
    typeInSearch("Test input")
}


â¸»

âœ… Benefits of This Framework

Feature	Benefit
DSL-Style Tests	Clean, expressive, and highly readable
Reusability	Core actions/assertions usable across modules
Modular Architecture	Easy to extend (add new matchers, actions, etc.)
Component-Based Robots	Mirrors UI structure, simplifies testing
MatchBuilder APIs	Powerful control for root windows, text matchers


â¸»

ğŸ“ Directory Summary

Folder	Purpose
actions/	Encapsulates test actions
assertions/	Contains assertions for verifying view states
matcher/	Contains matchers for locating views
builders/	Composes matchers dynamically
robots/	Screen/component-specific test logic
rules/	Contains custom rules (like AsyncTaskSchedulerRule)


â¸»

ğŸ“Œ Usage in NGA Module
	â€¢	The ui test framework is directly consumed in the nga module.
	â€¢	All XML UI component tests (accordion, switch, call-to-action) are written using robots and assertions defined in this framework.
	â€¢	Examples: ComponentListUITest.kt, AccordionComposeTest.kt, etc.

â¸»

ğŸ Next Steps
	â€¢	âœ… Add Compose-based counterpart (already seen in ButtonComposeTest.kt, AccordionComposeTest.kt)
	â€¢	ğŸ”„ Add CI integration to auto-run these tests
	â€¢	ğŸ” Add Allure/HTML test reporting

â¸»

Would you like me to export this to PDF, DOCX, or Confluence markdown?

Also, I can generate a Component Usage Diagram or UML structure if needed.